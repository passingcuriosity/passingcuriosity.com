--- 
wordpress_id: 1440
layout: post
title: The Natural Numbers
wordpress_url: http://passingcuriosity.com/2005/the-natural-numbers/
---
One of the statements in my calculus language is the operator declaration:<blockquote style="text-align: center; font-weight: bold;">Neg operator "~" has arity 1, fixity 0, priority 1.</blockquote>As negative numbers don't really make much sense as the arity and fixity of an operator, I've just spent a while knocking up a Haskell implementation of the <a href="http://en.wikipedia.org/wiki/Natural_numbers">natural numbers</a>.<br /><br />While I dislike programming in Java and other "OO" languages, they do make it <emph>a lot</emph> easier to extend types than is the case in Haskell. It would be much easier to do this sort of thing if Haskell supported instance declarations (the things that make most polymorphic functionality work in Haskell) on type synonyms. If it did, Natural.hs would be about 6 lines of code (plus a few lines of boiler plate) rather than nearly 60 lines.<br /><br />My new type Natural (just a wrapper around Integer) is an instance of eight separate type classes:<ol><li>Eq (they can be compared for equality)</li><li>Ord (values can be ordered with respect to each other)</li><li>Show (values can be converted to strings)</li><li>Read (values can be parsed out of strings)</li><li>Bounded (the range of values is bounded), though Natural shouldn't have an upper bound</li><li>Enum (values can be enumerated)</li><li>Num (values are numbers)</li><li>Real (values are real numbers)</li><li>Integral (values are integral numbers)</li></ol>It probably ought to have a few more like:<ul><li>Random (values can be randomly generated); and</li><li>Ix (values can used as array indices)</li></ul>but it'll get the job done -- all I need from it is Eq and Ord.
